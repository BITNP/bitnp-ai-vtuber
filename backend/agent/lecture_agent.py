"""
Lecture agent: play scripts generated by ppt_script
"""
from __future__ import annotations

from .abstract_agent import Agent, EventData

import asyncio
import base64
import os
import re
import sys
import urllib.parse
from typing import List, Dict, Optional

sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from stream_node import SentenceSepNode, BracketsParsorNode, LambdaNode
from tts import create_tts
from tts.pcm2wav import pcm2wav

from config_types import TTS_Config

PPT_TAG_PATTERN = re.compile(r"\[(?:PPT_([0-9]+)|翻页:?\s*([0-9]+))\]")


def _is_empty(content: str) -> bool:
    return not content.strip()


def _ws_to_http(ws_url: str) -> str:
    if ws_url.startswith("wss://"):
        return ws_url.replace("wss://", "https://", 1)
    if ws_url.startswith("ws://"):
        return ws_url.replace("ws://", "http://", 1)
    if ws_url.startswith("https://") or ws_url.startswith("http://"):
        return ws_url
    return "http://" + ws_url


class LectureAgent(Agent):
    def __init__(
        self,
        server_url: str,
        agent_name: str,
        tts_config: TTS_Config,
        tts_stream: bool = False,
        lecture_script_path: str | None = None,
        ppt_images_dir: str | None = None,
        ppt_base_url: str = "/documents/slides",
        auto_start: bool = True,
        **_kwargs,
    ):
        super().__init__(server_url, agent_name)

        self.tts = create_tts(**tts_config)
        self.tts_stream = tts_stream

        self.lecture_script_path = lecture_script_path
        self.ppt_images_dir = ppt_images_dir
        self.ppt_base_url = ppt_base_url.rstrip("/")
        self.auto_start = auto_start

        self._scripts: List[Dict] = []
        self._curr_index: int = 0
        self._play_task: Optional[asyncio.Task] = None
        self._pause_event = asyncio.Event()
        self._pause_event.set()
        self._started = False
        self._audio_seq = 0
        self._audio_waiters: dict[int, asyncio.Future] = {}
        self._audio_wait_timeout = 300

        # streaming workflow: sentence_sep -> brackets_parsor -> event_emitter
        self.sentence_sep_node = SentenceSepNode(seps="'.:;?!。：；？！\n")
        self.brackets_parsor_node = BracketsParsorNode()

        async def event_emitter_lambda(_, data):
            await self.handle_event(data)

        self.event_emitter = LambdaNode(event_emitter_lambda)

        self.sentence_sep_node.connect_to(self.brackets_parsor_node)
        self.brackets_parsor_node.connect_to(self.event_emitter)

        @self.on("lecture_control")  # type: ignore[misc]
        async def handle_lecture_control(_, timestamp: str, event_data: EventData):
            action = event_data.get("action", "")
            page = event_data.get("page")
            page_num = event_data.get("page_num", page)
            await self.apply_control(action, page_num)

        @self.on("audio_playback_finished")  # type: ignore[misc]
        async def handle_audio_playback_finished(_, timestamp: str, event_data: EventData):
            seq = event_data.get("seq")
            if seq is None:
                return
            waiter = self._audio_waiters.get(int(seq))
            if waiter and not waiter.done():
                waiter.set_result(True)

        self.loop(self._bootstrap_loop)  # type: ignore[arg-type]

    async def _bootstrap_loop(self, _agent: "LectureAgent"):
        if self._started:
            await asyncio.sleep(0.1)
            return

        if self.lecture_script_path:
            self._scripts = self.load_scripts(self.lecture_script_path)
        else:
            self._scripts = []

        if self.ppt_images_dir:
            await self.emit_ppt_assets(self.ppt_images_dir)

        if self.auto_start and self._scripts:
            await self.start_from_index(0)

        self._started = True

    def load_scripts(self, script_path: str) -> List[Dict]:
        if os.path.isdir(script_path):
            candidates = [
                os.path.join(script_path, f)
                for f in os.listdir(script_path)
                if f.endswith("_scripts.txt")
            ]
            candidates.sort()
            if not candidates:
                return []
            script_path = candidates[0]

        if not os.path.exists(script_path):
            return []

        with open(script_path, "r", encoding="utf-8") as f:
            content = f.read()
        return self.parse_script(content)

    def parse_script(self, content: str) -> List[Dict]:
        matches = list(PPT_TAG_PATTERN.finditer(content))
        if not matches:
            return []

        scripts: List[Dict] = []

        for i, match in enumerate(matches):
            start = match.end()
            end = matches[i + 1].start() if i + 1 < len(matches) else len(content)
            page_num = match.group(1) or match.group(2)
            if not page_num:
                continue
            text = content[start:end].strip()
            if _is_empty(text):
                continue
            scripts.append({"page_num": int(page_num), "content": text})
        return scripts

    async def emit_ppt_assets(self, images_dir: str):
        if not os.path.isdir(images_dir):
            return

        files = [
            f
            for f in os.listdir(images_dir)
            if f.lower().endswith((".png", ".jpg", ".jpeg", ".webp"))
        ]

        def sort_key(name: str):
            match = re.search(r"(\d+)", name)
            if match:
                return (0, int(match.group(1)))
            return (1, name)

        files.sort(key=sort_key)

        http_base = _ws_to_http(self.server_url)
        urls = [
            f"{http_base}{self.ppt_base_url}/{urllib.parse.quote(filename)}"
            for filename in files
        ]

        await self.emit({
            "type": "ppt_assets",
            "urls": urls,
            "total": len(urls)
        })

    async def apply_control(self, action: str, page_num: Optional[int] = None):
        action = (action or "").lower()

        if action == "pause":
            self._pause_event.clear()
            return
        if action == "resume":
            self._pause_event.set()
            return

        if not self._scripts:
            return

        if action == "next":
            target = min(self._curr_index + 1, len(self._scripts) - 1)
            await self.start_from_index(target)
        elif action == "prev":
            target = max(self._curr_index - 1, 0)
            await self.start_from_index(target)
        elif action == "replay":
            await self.start_from_index(self._curr_index)
        elif action == "goto" and page_num is not None:
            target = self._find_index_by_page(int(page_num))
            if target is not None:
                await self.start_from_index(target)

    async def start_from_index(self, index: int):
        if self._play_task:
            self._play_task.cancel()
            try:
                await self._play_task
            except asyncio.CancelledError:
                pass
        self.sentence_sep_node.reset()
        self._pause_event.set()
        self._play_task = asyncio.create_task(self._play_from_index(index))

    def _find_index_by_page(self, page_num: int) -> Optional[int]:
        for idx, item in enumerate(self._scripts):
            if item.get("page_num") == page_num:
                return idx
        return None

    async def _wait_if_paused(self):
        while not self._pause_event.is_set():
            await asyncio.sleep(0.1)

    async def _play_from_index(self, index: int):
        try:
            for i in range(index, len(self._scripts)):
                self._curr_index = i
                await self._wait_if_paused()

                item = self._scripts[i]
                page_num = item.get("page_num")
                content = item.get("content", "")

                if page_num is not None:
                    await self.emit({"type": "flip_ppt_page", "page_num": page_num})

                await self.emit({"type": "start_of_response"})

                await self.sentence_sep_node.handle(content)
                await self.sentence_sep_node.handle(" ")

                await self.emit({"type": "end_of_response", "response": content})
        except asyncio.CancelledError:
            return

    async def handle_event(self, data: dict):
        data_type = data.get("type", "")
        content = data.get("content", "")

        await asyncio.sleep(0)

        if data_type == "text":
            try:
                self._audio_seq += 1
                seq = self._audio_seq
                loop = asyncio.get_event_loop()
                self._audio_waiters[seq] = loop.create_future()

                if self.tts_stream:
                    chunks: List[bytes] = []
                    async for media_data in self.tts.synthesize_stream(content):  # type: ignore[misc]
                        chunks.append(media_data)

                    if not chunks:
                        waiter = self._audio_waiters.pop(seq, None)
                        if waiter and not waiter.done():
                            waiter.set_result(True)
                        return

                    first_pack = True
                    for idx, media_data in enumerate(chunks):
                        if self.tts.format == "pcm":
                            media_data = pcm2wav(
                                media_data,
                                sample_rate=self.tts.sample_rate,
                                channels=self.tts.channels,
                                bits_per_sample=self.tts.bits_per_sample,
                            )
                        base64_data = base64.b64encode(media_data).decode("utf-8")

                        is_last = idx == len(chunks) - 1

                        display_text = content if first_pack else ""
                        first_pack = False

                        await self.emit({
                            "type": "say_aloud",
                            "content": display_text,
                            "media_data": base64_data,
                            "format": "wav",
                            "seq": seq,
                            "is_last": is_last,
                        })
                else:
                    media_data = await self.tts.synthesize(content)
                    if self.tts.format == "pcm":
                        media_data = pcm2wav(
                            media_data,
                            sample_rate=self.tts.sample_rate,
                            channels=self.tts.channels,
                            bits_per_sample=self.tts.bits_per_sample,
                        )
                    base64_data = base64.b64encode(media_data).decode("utf-8")
                    await self.emit({
                        "type": "say_aloud",
                        "content": content,
                        "media_data": base64_data,
                        "format": "wav",
                        "seq": seq,
                        "is_last": True,
                    })

                waiter = self._audio_waiters.get(seq)
                if waiter:
                    try:
                        await asyncio.wait_for(waiter, timeout=self._audio_wait_timeout)
                    except asyncio.TimeoutError:
                        pass
                    finally:
                        self._audio_waiters.pop(seq, None)
            except Exception as e:
                print(f"TTS合成出错: {e}")
        elif data_type == "tag":
            tag_content = str(content)
            match = PPT_TAG_PATTERN.match(f"[{tag_content}]")
            if match:
                page_num = match.group(1) or match.group(2)
                if page_num:
                    await self.emit({"type": "flip_ppt_page", "page_num": int(page_num)})
                return
            await self.emit({"type": "bracket_tag", "content": tag_content})
